<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Improved 3D Editor</title>
    <style>
      body { margin: 0; overflow: hidden; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from "./node_modules/three/build/three.module.js";
      import { OrbitControls } from "./node_modules/three/examples/jsm/controls/OrbitControls.js";
      import { TransformControls } from "./node_modules/three/examples/jsm/controls/TransformControls.js";
      import { GUI } from "./node_modules/three/examples/jsm/libs/dat.gui.module.js";
      import { GLTFExporter } from "./node_modules/three/examples/jsm/exporters/GLTFExporter.js";
      import { OutlinePass } from "./node_modules/three/examples/jsm/postprocessing/OutlinePass.js";
      import { EffectComposer } from "./node_modules/three/examples/jsm/postprocessing/EffectComposer.js";
      import { RenderPass } from "./node_modules/three/examples/jsm/postprocessing/RenderPass.js";

      // Scene, Camera, and Renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Postprocessing setup
      const composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);
      
      // Outline pass with custom parameters for a subtle effect
      const outlinePass = new OutlinePass(new THREE.Vector2(window.innerWidth, window.innerHeight), scene, camera);
      outlinePass.edgeStrength = 2.0;
      outlinePass.edgeGlow = 0.0;
      outlinePass.edgeThickness = 0.5;
      outlinePass.pulsePeriod = 0;
      outlinePass.visibleEdgeColor.set('#00ff00');
      outlinePass.hiddenEdgeColor.set('#00ff00');
      composer.addPass(outlinePass);

      // OrbitControls for camera
      const controls = new OrbitControls(camera, renderer.domElement);
      const initialCameraPosition = new THREE.Vector3(0, 2, 5);
      camera.position.copy(initialCameraPosition);
      controls.target.set(0, 0, 0);
      controls.update();

      // Transform Controls
      const transformControls = new TransformControls(camera, renderer.domElement);
      scene.add(transformControls);
      transformControls.addEventListener("dragging-changed", (event) => {
        controls.enabled = !event.value;
      });

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      // A grid for reference
      const gridHelper = new THREE.GridHelper(10, 10);
      scene.add(gridHelper);
      const objects = []; // Store objects added to the scene
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);

      // Raycaster for selection
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let selectedObject = null;

      // GUI setup
      let gui = new GUI();
      const params = {
        gridVisible: true,
        addCube: () => {
          const cube = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff }));
          cube.position.set(Math.random() * 4 - 2, 0.5, Math.random() * 4 - 2);
          scene.add(cube);
          objects.push(cube);
        },
        addSphere: () => {
          const sphere = new THREE.Mesh(sphereGeometry, new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff }));
          sphere.position.set(Math.random() * 4 - 2, 0.5, Math.random() * 4 - 2);
          scene.add(sphere);
          objects.push(sphere);
        },
        mode: "translate",
        toggleGrid: () => {
          gridHelper.visible = params.gridVisible;
        },
        delete: () => {
          if (selectedObject) {
            scene.remove(selectedObject);
            objects.splice(objects.indexOf(selectedObject), 1);
            selectedObject = null;
            transformControls.detach();
            outlinePass.selectedObjects = [];
            resetGui();
          }
        },
        topView: () => {
          if (selectedObject) {
            camera.position.set(selectedObject.position.x, selectedObject.position.y + 5, selectedObject.position.z);
            camera.lookAt(selectedObject.position);
            controls.target.copy(selectedObject.position);
            controls.update();
          }
        },
        frontView: () => {
          if (selectedObject) {
            camera.position.set(selectedObject.position.x, selectedObject.position.y, selectedObject.position.z + 5);
            camera.lookAt(selectedObject.position);
            controls.target.copy(selectedObject.position);
            controls.update();
          }
        },
        resetCamera: () => {
          camera.position.copy(initialCameraPosition);
          controls.target.set(0, 0, 0);
          controls.update();
        },
        exportScene: () => {
          exportGLTF(objects);
        },
      };

      // Scene Folder in GUI with grid and object creation options
      function createSceneFolder(gui) {
        const sceneFolder = gui.addFolder('Scene');
        sceneFolder.add(params, 'addCube').name('Add Cube');
        sceneFolder.add(params, 'addSphere').name('Add Sphere');
        sceneFolder.add(params, 'exportScene').name('Export Scene');
        sceneFolder.add(params, 'gridVisible').name('Show Grid').onChange(params.toggleGrid);
        sceneFolder.add(params, 'mode', ['translate', 'rotate', 'scale']).name("Mode").onChange((value) => {
          transformControls.setMode(value);
        });
        sceneFolder.open();
      }

      function createCameraFolder(gui, isObjectSelected) {
        const cameraFolder = gui.addFolder("Camera");
        if (isObjectSelected) {
          cameraFolder.add(params, 'topView').name('Top View');
          cameraFolder.add(params, 'frontView').name('Front View');
        }
        cameraFolder.add(params, 'resetCamera').name('Reset Camera');
        cameraFolder.open();
      }

      function createObjectFolder(gui, object) {
        const objectFolder = gui.addFolder('Object');
        objectFolder.addColor({ color: object.material.color.getHex() }, 'color').name('Color').onChange((value) => {
          object.material.color.set(value);
        });
        objectFolder.add(params, 'delete').name('Delete Object');
        objectFolder.open();
      }

      // Update GUI based on selection
      function updateGuiForSelectedObject(object) {
        if (gui) gui.destroy();
        gui = new GUI();

        createSceneFolder(gui);
        createObjectFolder(gui, object);
        createCameraFolder(gui, true);  // Show camera options for object selection
      }

      function resetGui() {
        if (gui) gui.destroy();
        gui = new GUI();

        createSceneFolder(gui);
        createCameraFolder(gui, false);  // Basic camera controls
      }

      resetGui();

      // GLTF export function
      function exportGLTF(objects) {
        const exporter = new GLTFExporter();
        const sceneForExport = new THREE.Scene();

        // Only add user-created objects to export scene
        objects.forEach((obj) => {
          sceneForExport.add(obj.clone());
        });

        exporter.parse(sceneForExport, (result) => {
          const blob = new Blob([result], { type: 'model/gltf-binary' });
          saveAs(blob, 'scene.glb');
        }, { binary: true });
      }

      // Save function to trigger download
      function saveAs(blob, filename) {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
      }

      // Select object on click
      window.addEventListener('click', (event) => {
        if (event.target.closest('.dg')) return; // Ignore GUI clicks
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const intersects = raycaster.intersectObjects(objects);
        if (intersects.length > 0) {
          selectedObject = intersects[0].object;
          outlinePass.selectedObjects = [selectedObject];
          transformControls.attach(selectedObject);
          updateGuiForSelectedObject(selectedObject);
        } else {
          selectedObject = null;
          outlinePass.selectedObjects = [];
          transformControls.detach();
          resetGui();
        }
      });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        composer.render();
      }
      animate();
    </script>
  </body>
</html>
